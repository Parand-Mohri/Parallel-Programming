{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Task1:
\f1\b0 \
Race condition:\
It needs to be thread to have race condition.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 Multiple threads access at least one of the write. \
Example can be anything( code, real world examples, sketch,\'85)\
Deadlock:\
When two or more threads are dependent on each other, one need value of the other to work and the other way around. \
Two or more threads that wait for each other in circular fashion. \
Example\'97> the meme on the slides. Send receive example \
Example can be anything( code, real world examples, sketch,\'85)\
\

\f0\b Task 2: (MPI)
\f1\b0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 1. MPI_finalize after return. Switch \
2. MPI_WORLD is not exist \'97> its MPI_COMM_WORLD\
3. MPI_COMM_size and rand doesn\'92t return prices rank and count \'97> need to add the memorypoint of the variable \
4. Root process can\'92t be -1\'97> last MPI_Bcast \
5. MPI_init not mpi_initialize \
\

\f0\b Task3:(MPI)\

\f1\b0 Replace mpi send/ recive \'97> mai isend/irecive \
Use mpi wait after isend \
Irecive mpi wait after 
\f0\b \

\f1\b0 Second solution:\
Make sure free does not accuse before all the sends are over \'97> free after MPI_finalize \
Use mpi wait after receive \
\

\f0\b Task4:\

\f1\b0 a) there is intermediate buffer in asynchronized\
b) make processor works together to speed things up \
c) NB \'97> no . Difference: for NB request object \
\

\f0\b Task5:(openMP)\
\

\f1\b0 a)\
Programa omp parallel for reduction(+:s)\
 s+= a[i]
\f0\b \

\f1\b0 \
b)\
Long stemp = 0\
programa omp parallel private (stemp)\
Pragma openmp for \
Stemp += a[I]\
\
Pragma omp critical \
s++= stemp \

\f0\b \
Task6:\
\

\f1\b0 Static: devide num iterations by num threads \
Dynamic: each thread get initial working package, finished ask for new package. \
Guided: works like dynamic, size of packages are big at beginning and get smaller over time \

\f0\b \
 \
\
\
\
\
\
\
\
\

\f1\b0 \
}